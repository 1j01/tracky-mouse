<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' blob:">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Tracky Mouse</title>
	<script src="lib/stats.js"></script>
	<script src="lib/no-eval.js"></script>
	<script src="lib/clmtrackr.js"></script>
	<!-- <script src="lib/jsfeat-min.js"></script> exported from patched clmtrackr.js -->
	<link rel="stylesheet" type="text/css" href="tracky-mouse.css">
	<link rel="stylesheet" type="text/css" href="tracky-mouse-homepage.css">
	<link rel="icon" type="image/png" sizes="16x16" href="images/tracky-mouse-logo-16.png">
	<link rel="icon" type="image/png" sizes="512x512" href="images/tracky-mouse-logo-512.png">
</head>

<body>
	<header>
		<img src="images/tracky-mouse-logo-512.png" width="200" height="200" alt="" class="logo">
		<h1>Tracky Mouse</h1>
		<!-- <p class="tagline">Control your computer with your head!</p> -->
		<p class="tagline">Hands-free mouse control</p>
		<!-- <p class="tagline">Hands-free computer control</p> -->
	</header>
	<p>
		Tracky Mouse lets you control your computer with just a webcam.
	</p>
	<h2>Features</h2>
	<ul class="features-list">
		<li>
			<img src="images/input-head.svg" alt="Head with horizontal and vertical arrows">
			<div>
				<h3>Head Tracking</h3>
				<p>Precisely control the mouse cursor by moving your head.</p>
			</div>
		</li>
		<li>
			<img src="images/dwell-clicking.svg" alt="Mouse cursor with timer">
			<div>
				<h3>Dwell Clicking</h3>
				<p>Click by hovering over a control for a set amount of time. Cancel by moving away.</p>
			</div>
		</li>
		<li>
			<img src="images/manual-takeback.svg" alt="Mouse with hand grabbing it">
			<!-- <img src="images/input-mouse.svg" alt="Mouse with horizontal and vertical arrows"> -->
			<div>
				<h3>Manual Takeback</h3>
				<p>Regain control of the mouse by simply moving it. Head tracking will pause temporarily.</p>
			</div>
		</li>
		<!-- <li>
			<img src="images/keyboard-shortcuts.svg" alt="Keyboard with keys highlighted">
			<div>
				<h3>Keyboard Shortcuts</h3>
				<p>Use the keyboard to toggle head tracking, dwell clicking, and more.</p>
			</div>
		</li> -->
		<li>
			<img src="images/sliders.svg" alt="Sliders">
			<div>
				<h3>Settings</h3>
				<p>Adjust the sensitivity and smoothing of head tracking.</p>
			</div>
		</li>
		<!-- <li>
			<img src="images/gestures.svg" alt="Facial gestures">
			<div>
				<h3>Gestures</h3>
				<p>Blink, smile, or raise your eyebrows to trigger actions.</p>
			</div>
		</li> -->
		<!-- <li>
			<img src="images/open-source.svg" alt="Open source logo">
			<div>
				<h3>Free and Open Source</h3>
				<p>The software is yours forever.</p>
			</div>
		</li> -->
	</ul>
	<h2>The best of both worlds</h2>
	<p>
		Tracky Mouse combines state-of-the-art face detection with tried-and-true optical flow tracking
		to precisely control mouse movement with your head.
	</p>
	<div class="comparison-left-right">
		<p>
			<img src="images/enable-viacam.png" width="220" height="220" alt="">
			<a href="https://eviacam.crea-si.com/"><b>Enable Viacam</b></a>
			uses optical flow to track the movement of points on your face,
			but it has trouble finding your face in the first place.
		</p>
		<p>
			<img src="images/project-gameface.png" width="220" height="220" alt="">
			<a href="https://blog.google/technology/ai/google-project-gameface/"><b>Project Gameface</b></a>
			uses state-of-the art machine learning model FaceMesh to find your face,
			but cursor movement is very jittery because it uses the face position information directly.
		</p>
	</div>
	<div class="comparison-middle">
		<p>
			<b>Tracky Mouse</b> works like Enable Viacam, tracking points on your face precisely with optical flow,
			but it uses state-of-the-art face detection to place those points.
		</p>
		<p>
			Since the face detection is so good, it can place the points not just on your face,
			but at locations on your face that are ideal for tracking, and it can prune away the points
			when they stray from those specific locations on your face.
		</p>
		<p>
			The result is a system that's <b>more accurate than either.</b>
		</p>
	</div>
	<div class="cursors-background">
		<h2>Who is this for?</h2>
		<p>
			People who have limited mobility, due to motor neuron diseases like ALS,
			or other conditions that make it difficult to use a mouse,
			can greatly benefit from hands-free computer control.
		</p>
		<p>
			I hope to make it good enough that people want to use it even for common repetitive strain injuries like
			carpal tunnel syndrome.
		</p>
		<p>
			It's also just fun! It feels like controlling the computer with your mind.
		</p>
		<p>
			Ever wanted to use your computer while playing guitar, or while eating a sandwich?
			Maybe Tracky Mouse is for you!
		</p>
	</div>
	<h2>Try it out</h2>
	<p>
		<!-- TODO: write about what is and isn't part of the demo -->
		<!-- TODO: add dwell clicking to the demo, maybe with a little archery game or something -->
		<!-- TODO: maybe expose "Use Demo Footage" option I've used for testing (I'm not so much camera shy as worried about bloating the repo size...) -->
	</p>
	<div id="tracky-mouse-demo"></div>
	<h3 style="font-weight: normal; font-size: 5em; opacity: 0.5; margin: 0.2em; text-align: center;">
		Archery Practice Area
		<!-- ðŸ¹ -->
		<!-- Could be nice to represent the bow and arrow, but an emoji isn't cutting it for me. -->
	</h3>
	<!-- margin is radius of largest target -->
	<div id="archery-demo" style="position: relative; height: 400px; margin: 100px;">
		<button class="archery-target" style="--diameter: 200px; top: 50%; left: 50%"></button>
		<button class="archery-target" style="--diameter: 100px; top: 0%; left: 0%"></button>
		<button class="archery-target" style="--diameter: 100px; top: 0%; left: 100%"></button>
		<button class="archery-target" style="--diameter: 100px; top: 100%; left: 0%"></button>
		<button class="archery-target" style="--diameter: 100px; top: 100%; left: 100%"></button>
	</div>
	<h2>Download for desktop</h2>
	<p>
		Install the desktop app to control your whole computer.
	</p>
	<p>
		<!-- TODO: real download links; detect platform, present download with dropdown similar to VS Code homepage, near top of page -->
		<a href="https://github.com/1j01/tracky-mouse/releases" class="big-download-button">View Releases</a>
		- none yet
		<!-- <br>
		<a href="" class="secondary-download-button">Download for Windows</a>
		<br>
		<a href="" class="secondary-download-button">Download for Linux</a>
		<br>
		<a href="" class="secondary-download-button">Download for Mac</a> -->
	</p>
	<h2>Embed in your own web application</h2>
	<p>
		Most of the functionality of Tracky Mouse is available as a JavaScript library.
	</p>
	<p>
		You can use it to add head tracking and dwell clicking to your own web application.
	</p>
	<p>
		Check out the
		<a href="https://github.com/1j01/tracky-mouse/blob/main/API.md#tracky-mouse-api">API documentation</a>
		for more information.
	</p>
	<p>
		<a href="https://jspaint.app/about">JS Paint</a> uses Tracky Mouse for dwell clicking in its
		<a href="https://jspaint.app/#eye-gaze-mode">Eye Gaze Mode</a>.
	</p>
	<h2>Technical Info</h2>
	<p>
		This is a head tracking system similar to <a href="https://eviacam.crea-si.com/">eViacam</a>,
		using <a href="https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method">Lucasâ€“Kanade optical flow</a>
		to track points for high accuracy,
		and face detection for understanding of where to place tracking points.
		It uses two different face detectors, a fast-to-load one
		(<a href="https://github.com/auduno/clmtrackr">clmtrackr.js</a>)
		and a slower to load but much more accurate one
		(<a href="https://github.com/tensorflow/tfjs-models/tree/master/face-landmarks-detection">FaceMesh</a>),
		which it switches to automatically when available.
	</p>
	<p>
		<a href="https://inspirit.github.io/jsfeat/">JSFeat</a>
		is used for optical flow, and clmtrackr.js also uses JSFeat,
		so I patched clmtrackr.js to export JSFeat so it doesn't need to be loaded twice.
	</p>
	<p>
		clmtrackr.js used <code>eval</code> heavily, but I created
		<a href="eval-is-evil.html">a tool that eliminates the need for <code>eval</code></a>
		by running the code and seeing what it tries to evaluate,
		and creating functions that do the same thing.
		This allows Tracky Mouse to run in a context secured with <code>Content-Security-Policy</code>.
	</p>
	<h2>Source Code</h2>
	<p><a href="https://github.com/1j01/tracky-mouse">Open source on GitHub.</a> MIT-licensed.</p>
	<script src="tracky-mouse.js"></script>
	<script>
		TrackyMouse.dependenciesRoot = ".";
		// Note: init currently extends the passed element,
		// rather than replacing it or adding a child to it.
		// That is technically the most flexible, I suppose,
		// but may violate the principle of least surprise.
		// I could accept an options object with mutually exclusive options
		// to `extend`, `replace`, or `appendTo`.
		TrackyMouse.init(document.getElementById("tracky-mouse-demo"));

		// This example is based off of how JS Paint uses the Tracky Mouse API.
		// It's simplified a bit, but includes various settings.
		const config = {
			// The elements to click. Anything else is ignored.
			// TODO: maybe allow clicking on everything, but first
			// make sure to enable dwell clicking only when the head tracker is enabled.
			targets: ".archery-target",
			// targets: `
			// 	button:not([disabled]),
			// 	input,
			// 	textarea,
			// 	label,
			// 	a,
			// 	details summary,
			// 	.radio-or-checkbox-wrapper,
			// 	.drawing-canvas,
			// 	.window:not(.maximized) .window-titlebar
			// `,
			// Filter for elements to drag. They must be included in the targets first.
			shouldDrag: (target) => (
				target.matches(".window-titlebar") ||
				(target.matches(".drawing-canvas") && current_tool.supports_drag)
			),
			// Instead of clicking in the center of these elements, click at any point within the element.
			// This is useful for drag offsets, like for a window titlebar,
			// and position-based inputs like sliders or color pickers, or a drawing canvas.
			noCenter: (target) => (
				target.matches(`
					input[type="range"],
					.drawing-canvas,
					.window-titlebar
				`)
			),
			// Nudge hovers near the edges of an element onto the element itself,
			// to make it easier to click on the element.
			// More specifically it makes it easier to click on the edge of an element,
			// useful for a drawing canvas.
			retarget: [
				{ from: ".canvas-container", to: ".drawing-canvas", withinMargin: 50 },
			],
			// Elements that are equivalent are considered the same control.
			// This is useful for forms if you want the label of a radio button or checkbox
			// to be highlighted together with the radio button or checkbox.
			isEquivalentTarget: (apparent_hover_target, hover_target) => (
				apparent_hover_target.closest("label") === hover_target ||
				apparent_hover_target.closest(".radio-or-checkbox-wrapper") === hover_target
			),
			// Allow dwell clicking on a "Resume Dwell Clicking" button, while paused.
			dwellClickEvenIfPaused: (target) => (
				target.matches(".toggle-dwell-clicking-button")
			),
			// Define how to click on an element.
			click: ({ target, x, y }) => {
				if (target.matches("input[type='range']")) {
					// Special handling for sliders
					const rect = target.getBoundingClientRect();
					const vertical =
						target.getAttribute("orient") === "vertical" ||
						(getCurrentRotation(target) !== 0) ||
						rect.height > rect.width;
					const min = Number(target.min);
					const max = Number(target.max);
					target.value = (
						vertical ?
							(y - rect.top) / rect.height :
							(x - rect.left) / rect.width
					) * (max - min) + min;
					target.dispatchEvent(new Event("input", { bubbles: true }));
					target.dispatchEvent(new Event("change", { bubbles: true }));
				} else {
					// Normal click
					target.click();
					if (target.matches("input, textarea")) {
						target.focus();
					}
				}
			},
			// Handle untrusted gestures specially in external code.
			// Somewhere else, for example, you might do something like:
			// if (window.untrusted_gesture) {
			// 	// show download window
			// } else {
			// 	// show save file dialog with FS Access API
			// }
			// Recommended: use `event.isTrusted` instead, where possible.
			beforeDispatch: () => { window.untrusted_gesture = true; },
			afterDispatch: () => { window.untrusted_gesture = false; },
		};
		TrackyMouse.initDwellClicking(config);

		// Source: https://stackoverflow.com/a/54492696/2624876
		function getCurrentRotation(el) {
			const st = window.getComputedStyle(el, null);
			const tm = st.getPropertyValue("-webkit-transform") ||
				st.getPropertyValue("-moz-transform") ||
				st.getPropertyValue("-ms-transform") ||
				st.getPropertyValue("-o-transform") ||
				st.getPropertyValue("transform") ||
				"none";
			if (tm !== "none") {
				const [a, b] = tm.split('(')[1].split(')')[0].split(',');
				return Math.round(Math.atan2(a, b) * (180 / Math.PI));
			}
			return 0;
		}

		// Pointer event simulation logic should be built into tracky-mouse in the future.
		// These simulated events connect the Tracky Mouse head tracker to the Tracky Mouse dwell clicker,
		// as well as any other pointermove/pointerenter/pointerleave handlers on the page.
		const getEventOptions = ({ x, y }) => {
			return {
				view: window, // needed so the browser can calculate offsetX/Y from the clientX/Y
				clientX: x,
				clientY: y,
				pointerId: 1234567890, // a special value so other code can detect these simulated events
				pointerType: "mouse",
				isPrimary: true,
			};
		};
		let last_el_over = null;
		TrackyMouse.onPointerMove = (x, y) => {
			const target = document.elementFromPoint(x, y) || document.body;
			if (target !== last_el_over) {
				if (last_el_over) {
					const event = new PointerEvent("pointerleave", Object.assign(getEventOptions({ x, y }), {
						button: 0,
						buttons: 1,
						bubbles: false,
						cancelable: false,
					}));
					last_el_over.dispatchEvent(event);
				}
				const event = new PointerEvent("pointerenter", Object.assign(getEventOptions({ x, y }), {
					button: 0,
					buttons: 1,
					bubbles: false,
					cancelable: false,
				}));
				target.dispatchEvent(event);
				last_el_over = target;
			}
			const event = new PointerEvent("pointermove", Object.assign(getEventOptions({ x, y }), {
				button: 0,
				buttons: 1,
				bubbles: true,
				cancelable: true,
			}));
			target.dispatchEvent(event);
		};

		// Archery target hit animation
		const archery_targets = document.querySelectorAll(".archery-target");
		for (const archery_target of archery_targets) {
			archery_target.addEventListener("pointerdown", () => {
				// archery_target.style.animation = "archery-target-hit 0.5s ease-in-out";
				// archery_target.addEventListener("animationend", () => {
				// 	archery_target.style.animation = "";
				// }, { once: true });
				const frames = [];
				let angle = 0;
				let angularVelocity = 2 + Math.random() * 0.2;
				for (let t = 0; t < 100; t++) {
					angularVelocity *= 0.92;
					angle += angularVelocity;
					angularVelocity += (Math.sin(angle)) * 0.1;
					frames.push({
						transform: `translate(-50%, -50%) rotateX(${angle}rad)`,
						opacity: Math.min(1, Math.max(0.2, 1 - t / 100 * 4.123456) - Math.cos(angle) * 0.1),
					});
				}
				archery_target.animate(frames, {
					duration: 10000,
					easing: "linear",
				});
			});
		}
	</script>
</body>

</html>